resolver 1.1.1.1 ipv6=off valid=300s;

# Optional query params with sane defaults: ?stream=stable&arch=x86_64
map $arg_stream $fcos_stream { default stable; ~. $arg_stream; }
map $arg_arch   $fcos_arch   { default x86_64; ~. $arg_arch;   }

init_by_lua_block {
  local cjson = require "cjson.safe"
  local http  = require "resty.http"
  local dict  = ngx.shared.fcos_meta

  _G.fetch_fcos_meta = function(stream)
    stream = stream or "stable"
    local key_etag = "etag:"..stream
    local key_json = "json:"..stream

    local headers = {}
    local etag = dict:get(key_etag)
    if etag then headers["If-None-Match"] = etag end

    local httpc = http.new()
    httpc:set_timeout(5000)

    local host = "builds.coreos.fedoraproject.org"
    local url  = "https://"..host.."/streams/"..stream..".json"

    local res, err = httpc:request_uri(url, {
      method = "GET",
      headers = headers,
      ssl_verify = true,
      ssl_server_name = host,
    })
    if not res then return nil, "http:"..(err or "unknown") end

    if res.status == 304 then
      local cached = dict:get(key_json)
      if not cached then return nil, "cache_miss_304" end
      return cjson.decode(cached)
    elseif res.status == 200 then
      local new_etag = res.headers["ETag"]
      if new_etag then dict:set(key_etag, new_etag) end
      dict:set(key_json, res.body)
      return cjson.decode(res.body)
    else
      local cached = dict:get(key_json)
      if cached then return cjson.decode(cached) end
      return nil, "bad_status:"..res.status
    end
  end

  -- Hard-target: architectures.x86_64.artifacts.metal.formats.pxe
  local function pxe_node(meta)
    local arch = meta.architectures and meta.architectures["x86_64"]
    local metal = arch and arch.artifacts and arch.artifacts.metal
    local pxe = metal and metal.formats and metal.formats.pxe
    if not pxe then return nil, "no_pxe_section" end
    return pxe
  end

  -- Return the *location* URL for kernel/initramfs/rootfs
  _G.fcos_location = function(meta, component)
    local pxe, err = pxe_node(meta); if not pxe then return nil, err end
    local node = pxe[component]
    local loc = node and node.location
    if type(loc) == "string" and #loc > 0 then return loc end
    return nil, "no_location_for_"..tostring(component)
  end

  -- (Optional) helpers if you ever need them:
  _G.fcos_sha256 = function(meta, component)
    local pxe, err = pxe_node(meta); if not pxe then return nil, err end
    local v = pxe[component] and pxe[component].sha256
    if type(v) == "string" and #v > 0 then return v end
    return nil, "no_sha256_for_"..tostring(component)
  end
  _G.fcos_signature = function(meta, component)
    local pxe, err = pxe_node(meta); if not pxe then return nil, err end
    local v = pxe[component] and pxe[component].signature
    if type(v) == "string" and #v > 0 then return v end
    return nil, "no_signature_for_"..tostring(component)
  end
}


server {
  listen 8080;
  server_name _;

  # Common proxy defaults
  proxy_http_version 1.1;
  proxy_set_header Connection "";

  # Serve always-latest PXE pieces
location ~ ^/pxe/(kernel|initramfs|rootfs)$ {
    set $component $1;
    set $_upstream "";
    set $_upstream_host "";

    rewrite_by_lua_block {
      local stream = ngx.var.fcos_stream or "stable"
      local comp   = ngx.var.component

      local meta, err = fetch_fcos_meta(stream)
      if not meta then
        ngx.log(ngx.ERR, "FCOS meta fetch failed: ", err or "?")
        return ngx.exit(502)
      end

      local url, uerr = fcos_location(meta, comp)
      if not url then
        ngx.log(ngx.ERR, "FCOS missing PXE location for ", comp, ": ", uerr or "?")
        return ngx.exit(500)
      end

      local host = url:match("^https?://([^/]+)")
      if not host then
        ngx.log(ngx.ERR, "FCOS: could not parse host from URL: ", url)
        return ngx.exit(500)
      end

      ngx.var._upstream      = url
      ngx.var._upstream_host = host
    }

    proxy_cache            fcos_artifacts;
    proxy_cache_key        $scheme$proxy_host$uri;
    proxy_cache_methods    GET HEAD;
    proxy_cache_lock       on;
    proxy_cache_use_stale  updating error timeout http_500 http_502 http_503 http_504;
    proxy_cache_revalidate on;
    proxy_cache_valid      200 206 304 10m;
    proxy_force_ranges     on;

    proxy_ssl_server_name on;         # SNI for CloudFront
    proxy_ssl_name $_upstream_host;
    proxy_set_header Host $_upstream_host;

    proxy_pass $_upstream;
    add_header X-Cache-Status $upstream_cache_status always;
}

  # Quick version view (cached metadata)
location = /pxe/version.json {
  content_by_lua_block {
    local stream = ngx.var.fcos_stream or "stable"
    local meta, err = fetch_fcos_meta(stream)
    if not meta then
      ngx.status = 502
      ngx.say('{ "error":"origin_unreachable" }')
      return
    end

    local function info(comp)
      local url = fcos_location(meta, comp)
      local sha = _G.fcos_sha256(meta, comp)
      local sig = _G.fcos_signature(meta, comp)
      return string.format('"url":"%s","sha256":%s,"signature":%s',
        url or "",
        sha and ('" '..sha..' "') or 'null',
        sig and ('" '..sig..' "') or 'null'
      )
    end

    local arch = "x86_64"
    local rel = meta.architectures and meta.architectures[arch]
               and rel and rel.artifacts and rel.artifacts.metal
               and rel.artifacts.metal.release

    ngx.header["Content-Type"] = "application/json"
    ngx.print('{',
      '"stream":"', stream, '",',
      '"arch":"x86_64",',
      '"release":', rel and ('"'..rel..'"') or 'null', ',',
      '"kernel":{',    info("kernel"),    '},',
      '"initramfs":{', info("initramfs"), '},',
      '"rootfs":{',    info("rootfs"),    '}',
    '}')
  }
}

}
